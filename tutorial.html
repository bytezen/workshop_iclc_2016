<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>ICLC 2016 Workshop: Design a Mini-Language</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="css/normalize.css">
<link rel="stylesheet" href="css/skeleton.css">
<link rel="stylesheet" href="css/codemirror.css">
<link rel="stylesheet" href="css/github.min.css">

<script src="js/jquery.min.js"></script>

<script src="js/marked.js"></script>
<script src="js/highlight.min.js"></script>
<script src="js/hljs/javascript.min.js"></script>

<script src="js/peg.min.js"></script>
<script src="js/pegjs.pegjs.js"></script>

<script src="js/codemirror.min.js"></script>
<script src="js/mode/pegjs.min.js"></script>

<script src="js/big.min.js"></script>
<script src="js/gibberish.min.js"></script>
<script src="js/iclc.js"></script>

<style>
/* see http://getskeleton.com/ */
html { font-size: 50%; } 
table { width:100%; }
.input { min-height: 1em; width:50%; max-width: 50%; }
.result { 
	float: right;  
	width:45%; max-width: 45%; padding: 1%; 
	background: #eee; 
	word-wrap: break-word; 
	white-space: pre-wrap;       /* css-3 */
	white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
	white-space: -pre-wrap;      /* Opera 4-6 */
	white-space: -o-pre-wrap;    /* Opera 7 */
}
</style>
</head>
<body>

<script type="bogus" id="sourcetext">

# Tutorial

<div id="toc"></div>

**In any of the examples below, you can edit the input text and see the output immediately.**

## The most common grammar concepts

We write grammars as a set of pattern-based rules. A rule has: 

- a **name**, so that you can refer to it elsewhere, 
- a **pattern**, which defines what kinds of text it can recognize,
- an optional **action**, which defines what is returned when a rule applies.

The simplest grammar has only one rule, and the simplest kind of rule looks like this:

```peg
start = "hello"
```

Here `start` is the rule's name, and `"hello"` is the pattern it recognizes. In this case it will **match** the input only if the input has exactly the word *hello* (and nothing else). That is, if you give it the input string hello it will output "hello". But if you give it any other input string, like bye, it will result in an error like *Expected "hello" but "b" found.* Even an extra space or fullstop after the *hello* will break it. Try it:

<textarea class="input">hello</textarea>

Parsing grammars are often used to more than just *match* an input; they become really powerful when they do some kind of **translation** of the input. This generally means *modifying what a rule returns*. The concept of *modifying what a rule returns* is achieved through **actions**. Actions redefine what the rule returns when it matches input (rather than just returning the input itself). Actions are wrapped in ```{``` and ```}``` curly parentheses, and should contain a ```return``` statement to specify what is returned. For example, we could add an action to our parser to return our input in a different language:

```peg
start = "hello" { return "bonjour"; }
```

<textarea class="input">hello</textarea>

When considering a parser as a translator like this (sometimes also known as a "transpiler"), the language recognized and translated from is the **source language**, and the language produced as a result is the **target language**. We're going to be inventing new mini-languages for live coding as our source languages, and we're going to use a simple list-based instruction set for making sounds, loops, and so on as our target language. 

---

These are the basics. The rest is just learning how these can get more expressive. For example, the patterns of a rule can include more than just strings of text; they can have sequences, alternate options, optional items, and most importantly, they can refer to other rules. And as we shall see later, what goes between the ```{``` and ```}``` of an action is actually a fragment of Javascript code. That means we can do all kinds of interesting transformations in our translations.

---

### This then that (sequence)

There are only a handful of basic concepts used in the design of a rule's pattern. Let's look at the most common ones.

The simplest concept is of the *sequence of items*. And to specify this concept in a pattern, we just put each of the items in the pattern, with spaces between. For example, we could have considered our match of ```hello``` as matching a sequence of characters, and written it as follows. It functions in exactly the same way:

```peg
start = "h" "e" "l" "l" "o"
```

<textarea class="input">hello</textarea>

### This or that (alternates)

Grammars would be pretty uselessly inflexible if they only recognized one thing. To make flexibility we have a few options. For example, to recognize one of two words, we could use the ```/``` alternate symbol:

```peg
start = "hello" / "bye"
```

<textarea class="input">hello</textarea>

<textarea class="input">bye</textarea>

Problem is, this can only recognize the words we defined in the grammar. What if we wanted to recognize any old word (even nonsense and imaginary ones)? Well, remembering that we can split a word into a sequence of letters, let's simplify the problem to recognizing any letter. We could start with something like this:

```peg
letter = "a" / "b" / "c" / "d" / "e"
```

...and so on. Didn't want to write all 26 letters. 

### One of these (sets and ranges)

Luckily, there's a simple way to express a *set* of characters. It means, match any one of the items in the set. Sets are delimited by ```[``` and ```]``` square brackets like this:

```peg
letter = [abcdefghijklmnopqrstuvwxyz]
```

It's still a bit of a mouthful, so there's also a simpler way to express a *range* of characters, like this:

```peg
letter = [a-z]
```

<textarea class="input">a</textarea>

A set can contain several ranges and other characters, for example like thisrs, like this:

```peg
letter = [a-z] / [A-Z] / "@"
```

But this can be even more simply written as:

```peg
letter = [a-zA-Z@]
```

<textarea class="input">A</textarea>

### One or more

Now to make a word, we can use our letter rule, and we want to say that a word has *one or more* letters. The *one or more* concept is expressed by adding a ```+``` symbol to the end of the pattern, like this:

```peg
word = [a-zA-Z@]+
```

<textarea class="input">hello</textarea>

There's also a *zero or more* concept, which is expressed by adding ```*``` instead. We'll use that a bit later.

### Use a rule in many places

Since we'd already defined what a letter is, why not re-use it? Our grammars can easily use rules inside other rules, and this can make things easier to read, more flexible, and eventually also more powerful:

```peg
word = letter+
letter = [a-zA-Z@]
```

<textarea class="input">hello</textarea>

All this means is that to match the ```word``` rule, we have to match the ```letter``` rule, one or more times. Simple!

So how about a sentence? A sentence has one or more words, so we can use the ```+``` concept again. 

But words are separated by spaces. We can take a first stab at this by adding spaces to the ends of our words, like this:

```peg
sentence = word+
word = letter+ space
letter = [a-zA-Z@]
space = " "
```

To match the ```word``` rule here means you must find *one or more* ```letters```, followed by a ```space```. 

<textarea class="input">live coding</textarea>

We have a problem though. Given an input string ```"live coding"```, our grammar can match up to ```"live "``` as a word. But it can't match ```"coding"``` as a word, since it doesn't have a space after it. And since that fails, the whole parse will fail too. Only if the input has an extra space at the end will the parse succeed.

### Optional items

To work around this, we can use the concept of an *optional item*, which won't fail the parse if it isn't present. We mark the space as optional by adding a ```?``` to it:

```peg
sentence = word+
word = letter+ space?
letter = [a-zA-Z@]
space = " "
```

<textarea class="input">live coding</textarea>

Similarly, we could add support for sentences that end in an optional full stop (period) like this:

```peg
sentence = word+ "."?
word = letter+ space?
letter = [a-zA-Z@]
space = " "
```

<textarea class="input">live coding.</textarea>

We might even want to be flexible and allow multiple spaces, in which case we can use the concept of *zero or more times*, which we indicate with ```*```:

```peg
sentence = word+ "."?
word = letter+ space*
letter = [a-zA-Z@]
space = " "
```

<textarea class="input">live    coding.</textarea>

To recap, ```?``` means zero or one, ```*``` means zero or more, and ```+``` means one or more.

### Give me the raw text

Now look at that output -- what a mess of square brackets, spaces, and empty lists! 

Where did all those square brackets come from? Every time a *one or more* or *zero or more* rule is used, it will return a list of the items found. In our case for example this is happening in the ```letter+``` pattern. We probably don't want this much detail; we don't care about the individual letters, we just want the words as raw text. We can get that *just give it to me raw* concept by prefixing a pattern with a ```$```. (I don't know why a dollar means *just give it to me raw*.) For example:

```peg
sentence = word+ "."?
word = $letter+ space*
letter = [a-zA-Z@]
space = " "
```

<textarea class="input">live coding.</textarea>

This is better, but there are still lots of lists. Lists are also produced every time a *sequence* concept is used, such as ```*``` and ```+```. When a rule has a sequence of more than one element (like the ```space*``` in our ```word``` rule), it will also return a list to contain the elements' matches. 

Actually we don't really care about the spaces, we only want to keep the words. Here's how:

### Give me specific parts

Keeping certain parts means throwing others away. It implies *modifying what a rule returns* via an action, but to do this we also need to identify what parts of a pattern we are interested in keeping (also known as captures). We do this by giving them names (also known as labels) marked by the ```:``` colon character. For example, we can label the important part of our ```word``` pattern with the name "text" like this:

```peg
word = text:$letter+ space*
```

Once named, you can use this within the action like this:

```peg
sentence = word+ "."?
word = text:$letter+ space* { return text; }
letter = [a-zA-Z@]
space = " "
```

I.e. the rule matches words and spaces, but only returns the word parts. 

<textarea class="input">live coding.</textarea>

We can ignore the full stop in the same way:

```peg
sentence = words:word+ "."? { return words; }
word = text:$letter+ space* { return text; }
letter = [a-zA-Z@]
space = " "
```

The result looks immeasurably better:

<textarea class="input">live coding.</textarea>

Now you can easily imagine adding another rule for paragraphs as one or more sentences:

```peg
paragraph = sentence+
sentence = words:word+ "."? space* { return words; }
word = text:$letter+ space* { return text; }
letter = [a-zA-Z@]
space = " "
```

<textarea class="input">Live coding. For the win.</textarea>

Notice how the paragraph and sentence structure is now encoded in the list structure.

### Do some transformations on them

Since we're looking at the actions of a rule, it's worth mentioning that you can put pretty much any javascript in there:

```peg
paragraph = sentence+
sentence = words:word+ "."? space* { return words.join(""); }
word = text:$letter+ space* { return text[0].toUpperCase(); }
letter = [a-zA-Z@]
space = " "
```

<textarea class="input">Live coding. For the win.</textarea>


```peg
paragraph = sentences:sentence+ { return sentences.join(""); }
sentence = words:word+ "."? space* { return words.reverse().join("|")+"!!!"; }
word = text:$letter+ space* { return text.toUpperCase(); }
letter = [a-zA-Z@]
space = " "
```

<textarea class="input">I am calm. very calm.</textarea>

---

## Recap

Concept											| Syntax 
:--- 											| :---
Exactly the text "abc"							| ```"abc"```
A then B (sequence) 							| ```A B```
A or B (ordered choice) 						| ```A / B```
Optional A 										| ```A?```
Zero or more A's (returns an array)				| ```A*```
One or more A's (returns an array)				| ```A+```
Any one of these characters						| ```[abcdefgABCDEFG]```
 (or simply)									| ```[a-gA-G]```
Capture the raw text of the pattern	A			| ```$A```
Capture A as ```a``` and B as ```b``` for the action | ```a:A b:B```

That's nearly all the important concepts. There's a handful of other trickier ones but we'll get to them if we need to. But really, nearly everything can be done with the above handful.

---

## Example - musical notes

This page can also make sound! Click on the input box below and it will trigger the text to be parsed; and the output in this case will generate a note at frequency 440Hz and amplitude value of 1:

```peg
start = "a4" { return [440, 1, "@pluck-note"]; }
```

<textarea class="input">a4</textarea>

How about turning typical note names and chords, such as "c4", "Fbb5", etc. into MIDI equivalents, and then into Hz?

First, here's how to convert a midi pitch into hz:

```peg
hz = note { return 440 * Math.pow(2, (+text() - 69)/12); }
note = [0-9]+ { return +text(); }
```

<textarea class="input">69</textarea>

But we don't need to worry about that, as we have a built-in function ```mtof()`` that can do it for us. Plug it together:

```peg
start = pitch:note { return [mtof(pitch), 1, "@pluck-note"]; }
note = $[0-9]+
```

<textarea class="input">69</textarea>

Or we could say notes by their name "a", "b", etc.:

```peg
start = pitch:note { return [mtof(pitch), 1, "@pluck-note"]; }
note = "a" { return 69; } / "b" { return 71; } / "c" { return 60; }
```

<textarea class="input">a</textarea>

Alternatively, here's a more compact and flexible way:

```peg
start = pitch:note { return [mtof(pitch), 1, "@pluck-note"]; }

note = c:chroma { return c + 60; }

chroma = c:[a-gA-G] { 
    // return MIDI note offset from C:
    switch(c.toUpperCase()) {
    case "C": return 0; 
    case "D": return 2; 
    case "E": return 4; 
    case "F": return 5; 
    case "G": return 7; 
    case "A": return 9; 
    case "B": return 11; 
    }
}
```

<textarea class="input">a</textarea>

We could add on the octave, as "a0", "c1", "b4" etc.:

```peg
start = pitch:note { return [mtof(pitch), 1, "@pluck-note"]; }

note = c:chroma o:octave { return c + o; }

chroma = c:[a-gA-G] { 
    // return MIDI note offset from C:
    switch(c.toUpperCase()) {
    case "C": return 0; 
    case "D": return 2; 
    case "E": return 4; 
    case "F": return 5; 
    case "G": return 7; 
    case "A": return 9; 
    case "B": return 11; 
    }
}

octave = n:$("-"? [0-9]+)? { 
	if (n) { 
		// convert octave to MIDI note C:
		return 12 + (+n) * 12; 
	} else { 
		// octave wasn't specified, default to C4:
		return 60; 
	}
}
```

<textarea class="input">a4</textarea>

How about some accidentals:

```peg
start = pitch:note { return [mtof(pitch), 1, "@pluck-note"]; }

note = c:chroma a1:accidental a2:accidental o:octave { return c + a1 + a2 + o; }

chroma = c:[a-gA-G] { 
    // return MIDI note offset from C:
    switch(c.toUpperCase()) {
    case "C": return 0; 
    case "D": return 2; 
    case "E": return 4; 
    case "F": return 5; 
    case "G": return 7; 
    case "A": return 9; 
    case "B": return 11; 
    }
}

// sharps and flats
accidental = a:[#b]? {
    // return MIDI note offset:
    switch(a) {
    case "#": return +1;
    case "b": return -1;
    default: return 0;
    }
}

octave = n:$("-"? [0-9]+)? { 
	if (n) { 
		// convert octave to MIDI note C:
		return 12 + (+n) * 12; 
	} else { 
		// octave wasn't specified, default to C4:
		return 60; 
	}
}
```

<textarea class="input">C##4</textarea>

---

## Some common rules

### Empty space

Many grammars use the _ underscore character to identify areas of space, as it draws more attention to the other, more significant parts of patterns. (Except for languages in which space is really significant...). The following rules define optional and mandatory space, including tabs and newlines:

```peg
// optional space
_ = [ \t\r\n]*

// mandatory space
__ = [ \t\r\n]+
```

For example:

```peg
start = _ ("a"+ __)+

_ = [ \t\r\n]*
__ = [ \t\r\n]+
```

<textarea class="input"> a  a  
a aaa a  
a  a 
a a a   
</textarea>

### Numbers

TL;DR: -- captures decimal numbers and converts to Javascript numbers:

```peg
number = "-"? (([0-9]+ "." [0-9]*) / ("."? [0-9]+)) { return +text(); }
```

<textarea class="input">0.4</textarea>

Let's build that up. Here's a positive whole number:


```peg
positive_integer = [0-9]+ { return +text(); }
```

<textarea class="input">107</textarea>

Supporting negative whole numbers too is easy:

```peg
integer = "-"? [0-9]+ { return +text(); }
```

<textarea class="input">-123</textarea>

The use of ```text()``` is equivalent to wrapping ```$``` around the whole input -- i.e. it means give the entire input as raw text. The use of ```+``` is a cheap way of converting text into a javascript number.

Here's a basic decimal:

```peg
decimal = "-"? [0-9]+ "." [0-9]+ { return +text(); }
```

<textarea class="input">3.141</textarea>

However this fails for "1." and ".1", and "1". Here's a more robust version:

```peg
number = "-"? (([0-9]+ "." [0-9]*) / ("."? [0-9]+)) { return +text(); }
```

<textarea class="input">-.123</textarea>

How about ratios? For this we need the parts so we can do the division:

```peg
ratio = a:$("-"? [0-9]+) "/" b:$("-"? [0-9]+) { return +a / +b; }
```

<textarea class="input">1/-10</textarea>

Maybe want to add something special if b happens to be zero...

----

```peg
start = "hello" { return ["@pluck"]; }
```

<textarea class="input">hello</textarea>



</script>

<div class="container">
	<div class="row" style="margin-top: 25%">
		<div class="full column" id="main_body" />
	</div>
</div>

<script>

var body = document.getElementById('sourcetext').innerText;
document.getElementById('main_body').innerHTML = marked(body);
document.getElementById('toc').innerHTML = marked(toc.join("\n"));




$(".input").each(function() {
	$(this).keyup(function() { changed_value(this); });
	$(this).focus(function() { changed_value(this); });
	$(this).after('<code class="result"></code>');
	changed_value(this, true);
});


function changed_value(element, noplay) {
	var input = $(element)[0].value;
	// find previous grammar:
	var grammar = $(element).prevAll(":has(.lang-peg):first").find(".lang-peg")[0].innerText;
	
	var result = "";
	try {
		// update our parser:
		var parser = PEG.buildParser(grammar);
		var output = parser.parse(input);
		result = JSON.stringify(output);
		// try to play it?
		if (!noplay && Array.isArray(output)) {
			seq.define("default", output);
		}
	} catch(ex) {
		//console.log(ex.message);
		result = ex.message;
	}
	$(element).next( ".result" )[0].innerText = result; //.text(result);
}


</script>

</body>
</html>